<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KeyKernel&#39;s Blog</title>
  
  <subtitle>慕容医仙</subtitle>
  <link href="http://keykernel.org/atom.xml" rel="self"/>
  
  <link href="http://keykernel.org/"/>
  <updated>2021-12-13T14:45:58.000Z</updated>
  <id>http://keykernel.org/</id>
  
  <author>
    <name>KeyKernel</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>/dev/ptmx no space left on device</title>
    <link href="http://keykernel.org/2021/12/13/ptmx-no-space-left-on-device/"/>
    <id>http://keykernel.org/2021/12/13/ptmx-no-space-left-on-device/</id>
    <published>2021-12-13T14:29:18.000Z</published>
    <updated>2021-12-13T14:45:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 <code>docker exec -it 容器id bash</code> 进入容器时，出现错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">OCI runtime exec failed: exec failed: container_linux.go:370:starting container process caused:open /dev/ptmx: no space left on device: unknown<br></code></pre></td></tr></table></figure><p>这个问题主要是由于伪终端数量限制了，在相应的机器上，执行下面命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl -w kernel.pty.max=8192<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在使用 &lt;code&gt;docker exec -it 容器id bash&lt;/code&gt; 进入容器时，出现错误：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    
    <category term="docker" scheme="http://keykernel.org/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>打造自己的 dns 记录服务</title>
    <link href="http://keykernel.org/2021/12/12/dns-log-server/"/>
    <id>http://keykernel.org/2021/12/12/dns-log-server/</id>
    <published>2021-12-12T14:44:48.000Z</published>
    <updated>2021-12-13T14:27:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>2021年12月9日，Apache Log4j2 爆出核弹级漏洞，该漏洞可以远程代码执行，一旦被攻击者利用，将造成严重危害。各大公司均连夜进行应急处理和推送业务修复。<span id="more"></span></p><p>在漏洞处理和修复过程中，有个 dnslog 被广泛提及，主要是用于严重业务是否存在漏洞，代码或者命令是否真实执行，因为其使用 dns 查询请求的 payload 在受影响的用户端执行，dnslog 服务端记录 dns 请求，也被叫 dns 回显平台。  </p><p>这里，我们使用 go 开发一个 dns 记录服务，帮助业务快速自查风险。  </p><p>首先，定义一个 DNS 结构，用于存储真实服务解析。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> DNS <span class="hljs-keyword">struct</span> &#123;<br>Port   <span class="hljs-keyword">int</span>     <span class="hljs-comment">// 需要绑定的端口，一般为53</span><br>Domain <span class="hljs-keyword">string</span>   <span class="hljs-comment">// dns 解析服务提供泛解析的域名</span><br>Ip     net.IP   <span class="hljs-comment">// 域名需要被解析到的ip</span><br>&#125;<br></code></pre></td></tr></table></figure><p>绑定端口进行 udp 数据解析, 我们通过 dns 相关信息知道，dns 请求数据最长为 512 字节：  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dns *DNS)</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span></span> &#123; <br>  conn, err := net.ListenUDP(<span class="hljs-string">&quot;udp&quot;</span>, &amp;net.UDPAddr&#123;Port: dns.Port&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>  <span class="hljs-keyword">for</span> &#123;<br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">512</span>)<br>_, addr, _ := conn.ReadFromUDP(buf)<br>&#125;<br></code></pre></td></tr></table></figure><p>接着解包 dns 数据，这里需要使用到包 <code>golang.org/x/net/dns/dnsmessage</code> 。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := msg.Unpack(buf); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 解包失败丢弃，重新获取</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>  <span class="hljs-comment">// 过滤掉无效请求</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(msg.Questions) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>  <span class="hljs-comment">// 在协程里进行处理</span><br><span class="hljs-keyword">go</span> dns.ServerDNS(addr, conn, msg)<br></code></pre></td></tr></table></figure><p>在处理的时候，我们首先梳理下，需要做哪些事情：  </p><ol><li>拿到 client ip，用于定位哪个服务发起了这个域名的 dns 查询。</li><li>正常返回 dns 结果，主要为 A 记录和 AAAA 记录。</li><li>记录查询请求的域名信息、类型信息、clientip 进行存储。</li></ol><p>那我们开始吧，先拿到client ip:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dns *DNS)</span> <span class="hljs-title">ServerDNS</span><span class="hljs-params">(addr *net.UDPAddr, conn *net.UDPConn, msg dnsmessage.Message)</span></span> &#123;<br>req := msg.Questions[<span class="hljs-number">0</span>]<br>ip := addr.IP<br>port := addr.Port<br></code></pre></td></tr></table></figure><p>实际测试发现，获取到的 IP 为 dns 查询链路的最后一个节点的 IP 地址，查资料发现，dns 请求是一个类似深度递归一样的操作，每个节点单独与下一个节点连接查询，当前节点无法知道前面节点从哪里接到的请求。所以，实际在 dns 回显记录服务中，难以获取到 client ip 数据。</p><p>接着让正常请求能够返回，获取请求类型，判断是否是 A 或者 AAAA ，根据类型进行处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> reqTypeStr = req.Type.String()<br><span class="hljs-keyword">var</span> reqNameStr = req.Name.String()<br><span class="hljs-keyword">var</span> reqType = req.Type<br><span class="hljs-keyword">var</span> reqName, _ = dnsmessage.NewName(reqNameStr)<br><br>fmt.Printf(<span class="hljs-string">&quot;[%s] reqName: [%s] clientip: [%s]:[%d]\n&quot;</span>,<br>reqTypeStr, reqNameStr, ip, port)<br><br><span class="hljs-keyword">var</span> resource dnsmessage.Resource<br><span class="hljs-keyword">switch</span> reqType &#123;<br><span class="hljs-keyword">case</span> dnsmessage.TypeA:<br>    <span class="hljs-comment">// 解析所有后缀为 www.baidu.com 的域名</span><br><span class="hljs-keyword">if</span> strings.HasSuffix(reqNameStr, dns.Domain+<span class="hljs-string">&quot;.&quot;</span>) &#123;<br>ipv4 := dns.Ip.To4()<br><span class="hljs-keyword">if</span> ipv4 != <span class="hljs-literal">nil</span> &#123;<br>resource = dnsmessage.Resource&#123;<br>Header: dnsmessage.ResourceHeader&#123;<br>Name:  reqName,<br>Class: dnsmessage.ClassINET,<br>TTL:   <span class="hljs-number">600</span>,<br>&#125;,<br>Body: &amp;dnsmessage.AResource&#123;<br>A: [<span class="hljs-number">4</span>]<span class="hljs-keyword">byte</span>&#123;ipv4[<span class="hljs-number">0</span>], ipv4[<span class="hljs-number">1</span>], ipv4[<span class="hljs-number">2</span>], ipv4[<span class="hljs-number">3</span>]&#125;,<br>&#125;,<br>&#125;<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span><br>&#125;<br>msg.Response = <span class="hljs-literal">true</span><br>msg.Answers = <span class="hljs-built_in">append</span>(msg.Answers, resource)<br><span class="hljs-keyword">go</span> dns.SendAnswers(addr, conn, msg)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dns *DNS)</span> <span class="hljs-title">SendAnswers</span><span class="hljs-params">(addr *net.UDPAddr, conn *net.UDPConn, msg dnsmessage.Message)</span></span> &#123;<br>packed, err := msg.Pack()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> _, err := conn.WriteToUDP(packed, addr); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来试试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  ipAddr := net.ParseIP(<span class="hljs-string">&quot;1.1.1.1&quot;</span>)<br>dns := &amp;DNS&#123;Domain: <span class="hljs-string">&quot;www.baidu.com&quot;</span>, Port: <span class="hljs-number">8080</span>, Ip: ipAddr&#125;<br>dns.Start()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 dig 进行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">└─(17:01:07)──&gt; dig @127.0.0.1 -p 8080 111.www.baidu.com                     9 ↵ ──(星期日 21年12月12日)─┘<br><br>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @127.0.0.1 -p 8080 111.www.baidu.com<br>; (1 server found)<br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48203<br>;; flags: qr rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1<br>;; WARNING: recursion requested but not available<br><br>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 4096<br>;; QUESTION SECTION:<br>;111.www.baidu.com.INA<br><br>;; ANSWER SECTION:<br>111.www.baidu.com.600INA1.1.1.1<br><br>;; Query time: 1 msec<br>;; SERVER: 127.0.0.1#8080(127.0.0.1)<br>;; WHEN: Sun Dec 12 17:01:39 CST 2021<br>;; MSG SIZE  rcvd: 62<br></code></pre></td></tr></table></figure><p>我们看到，111.<a href="http://www.baidu.com/">www.baidu.com</a> 的 A 记录已经被正常的解析到了 1.1.1.1 这个 ip 地址。  </p><p>下面来搞定 AAAA 记录：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> dnsmessage.TypeAAAA:<br>   <span class="hljs-comment">// 解析所有后缀为 www.baidu.com 的域名</span><br><span class="hljs-keyword">if</span> strings.HasSuffix(reqNameStr, dns.Domain+<span class="hljs-string">&quot;.&quot;</span>) &#123;<br>ipv6 := dns.Ip.To16()<br><span class="hljs-keyword">if</span> ipv6 != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">var</span> ipV6 [<span class="hljs-number">16</span>]<span class="hljs-keyword">byte</span><br><span class="hljs-built_in">copy</span>(ipV6[:], ipv6)<br>resource = dnsmessage.Resource&#123;<br>Header: dnsmessage.ResourceHeader&#123;<br>Name:  reqName,<br>Class: dnsmessage.ClassINET,<br>TTL:   <span class="hljs-number">600</span>,<br>&#125;,<br>Body: &amp;dnsmessage.AAAAResource&#123;<br>AAAA: ipV6,<br>&#125;,<br>&#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>这样服务就已经的对域名的 A 和 AAAA 记录了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[TypeA] reqName: [111.www.baidu.com.] clientip: [127.0.0.1]:[60065]<br>[TypeAAAA] reqName: [111.www.baidu.com.] clientip: [127.0.0.1]:[50532]<br></code></pre></td></tr></table></figure><p>后续只需要进行 dns 记录的存储和查询。在公司内部，也可以将 dnslog 的请求，全部转发到该服务，即可感知到所有被外部检查的存在漏洞的服务了。同时提供查询和删除的管理界面，也能给业务进行自查，帮助业务更快的修复安全漏洞。  </p><p>最后，祈福永无BUG，无安全漏洞！！！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021年12月9日，Apache Log4j2 爆出核弹级漏洞，该漏洞可以远程代码执行，一旦被攻击者利用，将造成严重危害。各大公司均连夜进行应急处理和推送业务修复。</summary>
    
    
    
    
    <category term="dns" scheme="http://keykernel.org/tags/dns/"/>
    
    <category term="log4j" scheme="http://keykernel.org/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>go get 时出现 SSL certificate problem</title>
    <link href="http://keykernel.org/2021/12/12/go-get-ssl-certificate-problem/"/>
    <id>http://keykernel.org/2021/12/12/go-get-ssl-certificate-problem/</id>
    <published>2021-12-12T02:40:01.000Z</published>
    <updated>2021-12-12T15:57:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 go get 下载依赖时，出现 SSL certificate problem: certificate has expired 错误<span id="more"></span>：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get gopkg.in/ini.v1                               <br><span class="hljs-comment"># cd .; git clone -- https://gopkg.in/ini.v1 /Users/xxx/go/src/gopkg.in/ini.v1</span><br>Cloning into <span class="hljs-string">&#x27;/Users/xxx/go/src/gopkg.in/ini.v1&#x27;</span>...<br>fatal: unable to access <span class="hljs-string">&#x27;https://gopkg.in/ini.v1/&#x27;</span>: SSL certificate problem: certificate has expired<br>package gopkg.in/ini.v1: <span class="hljs-built_in">exit</span> status 128<br></code></pre></td></tr></table></figure><p>这是该模块所在服务端使用的 https 证书问题，certificate has expired 是证书已经过期，类似的错误还有 Invalid 无效证书等。可以通过设置不进行证书验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config –global http.sslVerify <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p> 另外，也可以通过查找该模块是否有 github 的托管，通过 github 的地址拉取，例如 <code>gopkg.in/ini.v1</code> 模块在 github 上的仓库为 <code>github.com/go-ini/ini</code> 。可以通过 <code>go get github.com/go-ini/ini</code>  获取。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 go get 下载依赖时，出现 SSL certificate problem: certificate has expired 错误</summary>
    
    
    
    
    <category term="go" scheme="http://keykernel.org/tags/go/"/>
    
    <category term="git" scheme="http://keykernel.org/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>利用github分支同步博客代码，方便不同机器上更新博客</title>
    <link href="http://keykernel.org/2018/05/13/hexo-blog-sync-git-branch/"/>
    <id>http://keykernel.org/2018/05/13/hexo-blog-sync-git-branch/</id>
    <published>2018-05-13T06:51:29.000Z</published>
    <updated>2021-07-18T02:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用github搭建博客后，每次更新需要在原来的代码基础上更新。如果在其他个人电脑上，没有原来的代码，则无法立即同步更新博客。这时候我们可以选择将代码push到一些代码服务器上，但是我们这里可以这么做。<span id="more"></span><br>首先，我们先对github中博客的代码仓库建立一个新的分支hexo_code，并设置代码库的Branches-&gt;Default branches为新建的分支hexo_code。<br>克隆代码库到本地:  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Users/page.github.com.git<br><span class="hljs-built_in">cd</span> page.github.com.git<br></code></pre></td></tr></table></figure><p>将博客代码全部拷贝到page.github.com.git目录, 如果themes不是使用的默认的theme。则需要删除掉该主题目录中的.git目录。<br>这时我们就可以把当前目录全部推送到github的新branches了。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&#x27;new&#x27;</span><br>git push origin hexo_code<br></code></pre></td></tr></table></figure><p>这样我们在其他的电脑上，只需要clone代码(记得添加ssh key)，并在目录中执行npm install。之后就能按照正常的操作更新博客了。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git@github.com:Users/page.github.com.git<br><span class="hljs-built_in">cd</span> page.github.com.git<br>npm install //在其他机器上执行  <br><br>//更新博客  <br>hexo new <span class="hljs-string">&#x27;test&#x27;</span> //新建文章  <br>hexo g          //生成页面代码  <br>hexo d          //部署页面  <br><br>//同步博客代码到git  <br>git add <span class="hljs-built_in">source</span>/_posts/test.md<br>git commit -m <span class="hljs-string">&quot;new up test&quot;</span><br>git push origin hexo_code<br></code></pre></td></tr></table></figure><p>done.  </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用github搭建博客后，每次更新需要在原来的代码基础上更新。如果在其他个人电脑上，没有原来的代码，则无法立即同步更新博客。这时候我们可以选择将代码push到一些代码服务器上，但是我们这里可以这么做。</summary>
    
    
    
    
    <category term="hexo" scheme="http://keykernel.org/tags/hexo/"/>
    
    <category term="github" scheme="http://keykernel.org/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>使用user账号登录docker容器</title>
    <link href="http://keykernel.org/2018/05/13/docker-run-in-user/"/>
    <id>http://keykernel.org/2018/05/13/docker-run-in-user/</id>
    <published>2018-05-13T05:30:49.000Z</published>
    <updated>2021-07-18T02:47:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>平时工作中，使用docker容器时，均使用的root账号登录。但是有时候，你需要使用其他的账号，部署一些需要权限限制的服务，例如nginx。<span id="more"></span><br>使用下列步骤即可完成使用普通用户登录docker。<br>第一步，启动你的容器并以root进入，创建一个work账号：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">useradd -d /home/work work<br></code></pre></td></tr></table></figure><p>第二步，为用户设置登录密码：  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">[root@<span class="hljs-built_in">test</span>]&gt; passwd work<br>Changing password <span class="hljs-keyword">for</span> user work.<br>New UNIX password:<br>Retype new UNIX password:<br>passwd:all authentication takens updated successfully.<br></code></pre></td></tr></table></figure><p>第三步，设置用户主目录，由于之前使用的root创建的/home/work，这时候登录会有问题。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">//如果没创建则创建<br>//mkdir -p /home/work<br>chown work:work /home/work //设置目录拥有者和组<br>//如果该目录有子目录<br>//chown -R work:work /home/work<br></code></pre></td></tr></table></figure><p>这时候就可以使用work账号进行登录。  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">//退出容器进入宿主机执行<br>docker <span class="hljs-built_in">exec</span> -it --user=work <span class="hljs-built_in">test</span> bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;平时工作中，使用docker容器时，均使用的root账号登录。但是有时候，你需要使用其他的账号，部署一些需要权限限制的服务，例如nginx。</summary>
    
    
    
    
    <category term="Docker" scheme="http://keykernel.org/tags/Docker/"/>
    
  </entry>
  
</feed>
